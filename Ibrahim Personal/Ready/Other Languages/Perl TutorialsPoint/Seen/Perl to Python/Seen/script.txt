#########################################################################
#GPIB interface for 4156C
########################################################################


BEGIN {unshift(@INC, "." , ".." , "\\Micron\\Nextest\\perl_modules");}


use runcli;																		# Enable input from perl script as nextest cli command, Runcli is the command that youâ€™ll use to communicate with the tester
use getHost;                 													# To latch in module/ "library into current script, here the getHost.pm is loaded, used once on nextest system



#open FILE,">","iv.txt" or die $!;												# Make file ready for reading from FILE

#$k=139;
#while($k<153)
#{
#$j=0;
#while($j<4)
#{
$i=0;																			
$j=132;
while($j<156)
{
$logfile = "vpgmcp"."freq"."$j"."."."txt";										# Give the name to the logfile
open(LOG,">$logfile") or die $!;												# Makes the file ready for reading from LOG

#******************* SUBS ****************************

if($i==0)

																		
{													
runcli("gpibinit;");															
runcli("gpibsend(0x1,\":PAGE:CHAN:MODE SWEEP\")");								# PAGE, CHANnel, MODE, Set the mode to sweep

runcli("gpibsend(0x1,\":PAGE:CHAN:SMU1:VNAME 'Vout'\")");						# Source Monitor Unit, voltage name Vout
runcli("gpibsend(0x1,\":PAGE:CHAN:SMU1:INAME 'Iout'\")");						# current name Iout
runcli("gpibsend(0x1,\":PAGE:CHAN:SMU1:MODE V\")");								# voltage output node
runcli("gpibsend(0x1,\":PAGE:CHAN:SMU1:FUNCTION VAR1\")");						# function Variable

runcli("gpibsend(0x1,\":PAGE:CHAN:SMU2:VNAME 'Vcc'\")");
runcli("gpibsend(0x1,\":PAGE:CHAN:SMU2:INAME 'Icc'\")");
runcli("gpibsend(0x1,\":PAGE:CHAN:SMU2:MODE V\")");
runcli("gpibsend(0x1,\":PAGE:CHAN:SMU2:FUNCTION CONSTANT\")");					# function constant


runcli("gpibsend(0x1,\":PAGE:CHAN:SMU3:DIS\")");

runcli("gpibsend(0x1,\":PAGE:CHAN:SMU4:DIS\")");

runcli("gpibsend(0x1,\":PAGE:CHAN:VSU1:DIS\")");								# Voltage Source Unit DISabled

runcli("gpibsend(0x1,\":PAGE:CHAN:VSU2:DIS\")");


runcli("gpibsend(0x1,\":PAGE:DISP:LIST:SELECT 'Iout'\")");						# DISPlay LIST
runcli("gpibsend(0x1,\":PAGE:DISP:LIST:SELECT 'Vcc'\")");
runcli("gpibsend(0x1,\":PAGE:DISP:LIST:SELECT 'Icc'\")");
runcli("gpibsend(0x1,\":PAGE:DISP:LIST:SELECT 'Vout'\")");


runcli("gpibsend(0x1,\":PAGE:MEAS:SWEEP:VAR1:MODE SINGLE\")");					# Single Stair Sweep
runcli("gpibsend(0x1,\":PAGE:MEAS:SWEEP:VAR1:SPACING LINEAR\")");				# The sweep is incremented (decremented) by the
																				# stepsize until the stop value is reached.



runcli("gpibsend(0x1,\":PAGE:MEAS:SWEEP:VAR1:START 10\")");						# Setting the sweep range of Vout
runcli("gpibsend(0x1,\":PAGE:MEAS:SWEEP:VAR1:STOP 30\")");
runcli("gpibsend(0x1,\":PAGE:MEAS:SWEEP:VAR1:STEP 0.1\")");
		runcli("gpibsend(0x1,\":PAGE:MEAS:SWEEP:VAR1:COMPLIANCE 0.05\")");				# Compliance: meaning the stable state of voltage
		runcli("gpibsend(0x1,\":PAGE:MEAS:SWEEP:VAR1:PCOMPLIANCE:STATE 0\")");			# PCOMPLIANCE: Might be the state before the stable state

		runcli("gpibsend(0x1,\":PAGE:MEAS:DEL 2\")");									# Delay	
		runcli("gpibsend(0x1,\":PAGE:MEAS:HTIM 50\")");									# Hold Time

runcli("gpibsend(0x1,\":PAGE:MEAS:SWEEP:CONS:SMU2:SOURCE 3.3\")");				# Setting the values for VCC
runcli("gpibsend(0x1,\":PAGE:MEAS:SWEEP:CONS:SMU2:COMP 0.1\")");
runcli("gpibsend(0x1,\":PAGE:SCON:SING\")");									# This Command starts single measurement options
sleep(2);																		# Give equipment time to respond to configuration command. 
runcli("ctst");
runcli("stst");
sleep(2);
runcli("vpgmcp.txt()");
runcli("regaccess(static_load,0x9,0x9,$j)");									# Using the Cregs 0x9 to modulate the frequency
runcli("rs");





			poll_4156c();									
}

			sub poll_4156c{
runcli("gpibsend(0x1,\":STAT:OPER:COND?\");");									# This command returns the present status of the Operation
																				# Status "CONDITION" register. Reading this register does not clear it.
runcli("gpibreceive(0x1);");
while((get_gpib_status() > 0)&&($foundError < 1) ){
sleep(3);
runcli("gpibsend(0x1,\":STAT:OPER:COND?\")");
runcli("gpibreceive(0x1);");
}

}#end poll_4156c subroutine





sub get_gpib_status{
use getHost;                 													
# get file info
$host_meas = getHost(); 														# Retrieve the nextest station detail, will return something like mav2pt - 0014
$file_meas = $host_meas."_temp.cli";											# Define the file_meas as the nextest cli temporary file, Contains all the text as displayed on Nextest CLI
	open(STATUS, "$file_meas" ) || die("Can't open logfile: $!");
	print "\nSTATUS received from GPIB:";	
	while(<STATUS>)
		{
        if(/Error/){
        runcli("gpibinit;");    
        $foundError = 1;
        }
        else
        {
            chomp;
            s/\+//g;
            $value = $_;
            $foundError = 0;
        }
    } # End of while(<INMEAS>) loop.
	close(STATUS);
print " $value";
return($value);
}#End of get_gpib_status subroutine.





if($foundError <1){
print LOG "\n";
get_sweep_data2(Vout);
print LOG "\n";

get_sweep_data2(Iout);
print LOG "\n";
#function_file($logfile);
get_sweep_data2(Vcc);
print LOG "\n";
#function_file($logfile);
get_sweep_data2(Icc);
}
$j=$j+8;
}


  

sub get_sweep_data2
{
$count=1;
$temp = "$_[0]";
$cli_file = getHost() . "_temp.cli";


#~ print "\n sweep parameter $temp";

runcli("gpibsend(0x1,\":FORM:BORD NORM\")");
runcli("gpibsend(0x1,\":FORM:DATA ASC\")");
runcli("gpibsend(0x1,\":TRAC? '$temp'\")");
runcli("gpibreceive(0x1,,ex1)");

open(IN,"<$cli_file") or die $!;

	while(<IN>) {
	if($count>=3)
	{
	$abg =$_;
@abg=split(/\n/,$abg);
print LOG "@abg";
	}
	$count=$count+1;
	}
	
	close(IN);
	 

}



















