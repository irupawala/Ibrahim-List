1. Destructor 
2. Destructor in Inheritance
3. Virtual Destructor



1. Destructor:

Class Base
{

public:
	Base()
	{
	cout << "Base constructor" << endl;
	}

	~Base()
	{
	cout << "Base destructor" << endl;
	}
};

class Derived: public Base 
{

public:
	Derived()
	{
	cout << "Derived constructor" << endl;
	}
	
	~Derived()
	{
	cout << "Derived destructor" << endl;
	}
	
};

int main()
{
Derived d;
}

- Destructor is used for deallocating resources like releasing memory, network connection.

2. Destructor in inheritence:

- We know that when the derived class is called the constructor of the base class is called first
and then the derived class constructor is called.

- For Destructor, Destructor is called when the object is destroyed, hence here the destructor will be
called at the end of the program. 
- For Destructor, DESTRUCTOR OF THE DERIVED CLASS IS CALLED FIRST AND THEN THE DESTRUCTOR OF THE BASE CLASS
IS CALLED

3. Virtual Destructor 

int main()
{

Base *p = new Derived();


delete p;

}

// consider a base class pointer pointing to an object of the derived class created dynamically in heap.

* Now here when we do delete p then the base class Destructor is called as in C++ functions
are called depending on the pointer BUT THE OBJECT IS OF THE DERIVED CLASS.

* Hence the destructor of derived class should be called first and then destructor of the base class should 
be called but unfortunately this doesn't happen in C++ as in C++ the functions are called based
on pointer. Here the compiler thinks that the object is of the base class. It will not see what object
is attached.

* Hence to call the destructor in the order of derived first and then base we have to write a virtual destructor


Class Base
{

public:
	Base()
	{
	cout << "Base constructor" << endl;
	}

	virtual ~Base()
	{
	cout << "Base destructor" << endl;
	}
};

class Derived::public Base 
{

public:
	Derived()
	{
	cout << "Derived constructor" << endl;
	}
	
	~Derived()
	{
	cout << "Derived Destructor" << endl;
	}
	
};

int main()
{

Base *p = new Derived();


delete p;

}

* Note here if we don't use the virtual destructor then the resources acquired by base class will
only get released but the resources acquired by derived class will not be released and hence
the problem of memory leak will occur.

* Hence if IN THE PROGRAM YOU ARE USING BASE CLASS POINTER AND DERIVED CLASS OBJECT THEN VIRTUAL BASE
DESTRUCTOR IS A MUST.

* Hence base class pointer and derived class object is used for achieving runtime polymorphism. Hence 
if we want to achieve runtime polymorphism then we have to make runtime functions as virtual and similarly
destructor should also be made virtual
