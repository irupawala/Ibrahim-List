Usage of Constants:

1. Used as a constant identifer inside a function or class.

- If we write

const int x = 10; // then it becomes constant identifiers and this constant identifier cannot be modified.

The properties of constant identifiers are as follows:

1. constant identifier is a also an identifier like variable albeit this identifier cannot be modified.
2. This will consume memory as per the datatype declared
3. constants are the part of the compiler.
4. Used for declaring constants inside the class or function

- In contrast #define x 10 is also a constant but it is a preprocessor directive 
and it is executed before compilation process starts.

The properties of preprocessor directive are as follows:

1. x also cannot be modified.
2. preprocessor directives does not hold space in memory. It is just like a symbol.
3. This is not part of a language. It is outside compiler meaning pre-compiler
4. These are used for declaring constants if it is used by the entire program just like a global variable.

2. Used as a pointer of type constant integer.

int main()
{

int x = 10;	// notice that here we cannot simply write const int x=10 and expect that pointer can point to it
const int *ptr=&x;
// int const *ptr=&x; // This can also be written this way
++ *ptr;
cout << *ptr;
}

- Note that in this case CONSANT TO AN INTEGER POINTER cannot modify x when we write ++ *ptr because data is locked

Also note that cout << *ptr can access the value of x but cannot modify it as it will treat the data as constant.

** Notice that here we cannot simply write const int x=10 and expect that pointer can point to it
** Address of constant identifier cannot be stored to the pointer hence we have to make a constant pointer
** This can be read from right to left as pointer of type integer constant.
** Also note that after making the pointer of type integer constant we can also define int x as const and 
it will work as expected. Also we can directly make pointer of type int constant without defining x as const explicitly

int main()
{

int x = 10;
const int *ptr=&x;
// int const *ptr=&x; // This can also be written this way
int y = 20;
ptr = &y; // now we are pointing the same pointer to address of y
++ *ptr; // This cannot be modified as the integer is a constant.
cout << *ptr;
}

* In this case now the pointer will point to the address of y but note that even now it won't be able
to modify the value of y.

3. Used as a constant pointer of type integer 

Instead of int const *ptr if we write int *const ptr then instead of data, pointer becomes locked now and
hence cannot be modified. This means that pointer can now point to only one address which cannot be changed.


int main()
{

int x = 10;
int * const ptr=&x; // This is now constant pointer of type integer
int y = 20;
ptr = &y; // This is not possible now as the pointer itself is constant
++ *ptr; 
cout << *ptr;
}

4. Used as a constant pointer to integer contant

If we write const before the constant pointer of type integer then it becomes constant pointer
to integer constant. Hence now data is constant and also pointer is constant.

int main()
{

int x = 10;
const int * const ptr=&x; // This is now constant pointer to integer constant
int y = 20;
ptr = &y; // This is not possible now as the pointer itself is constant
++ *ptr; // Now this is also not possible as data cannot be modified.
cout << *ptr;
}


5. Constant Function:

class Demo
{
public:
	int x=10;
	int y=20;
	
void Display() const
{

x++;
cout << x << y << endl;
}

};

In this example if we don't want the member function to modify the values of data members then
we can write const at the end of the member function

- These are helpful when we want the member function to avoid modifying the data members by mistake.

6. constant call by reference

void fun(int &x, int &y) // call by reference hence x and y are alias of a and b respectively
// also notice that for call by reference we know that the function fun will be copied at the place of 
// function definition hence it becomes inline function because as we know that it is not possible for
// the function to modify the values of another function unless being an inline function. 
{
x++;
cout << x<<" " <<y;
}

int main()
{
int a = 10, b=20;
fun(a,b);
}


- One of the benefits of the inline functions is it makes the code simple as the function is copied to 
the place of the function definition but there is one big disadvantage. This is that lets say here in the 
function x is being incremented but now x is an alias of a hence the function is modifying the original integer 
a. If we don't want to allow the function fun to modify the values of the original function we can define 
them as const as shown below:

void fun(const int &x, int &y)
{
x++;
cout << x<<" " <<y;
}

int main()
{
int a = 10, b=20;
fun(a,b);
}








