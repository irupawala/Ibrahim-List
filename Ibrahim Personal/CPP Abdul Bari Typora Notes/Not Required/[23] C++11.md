# [23] C++11

## [23.1] Auto

- Auto is used when we don't know the type of the data
- decltype is used in c++ to capture the datatype of one variable and give it to other.

```c++
#include <iostream>

using namespace std;

float fun()
{
    return 2.34f;
}

int main()
{
    // auto is used when we don't know the type of the data
    auto x  = 2*4.59 + 'a';
    auto y = fun();
    cout << x << endl;
    cout << "Value returned from func " << y << endl;

    // decltype is used in c++ to capture the datatype of one variable and give it to other.
    
    // here the type of y is given to z

    decltype(y) z = 12.3;

    return 0;
}

```

## [23.2] Final Keyword

- Final keyword restricts Inheritance and function over-riding

E.g. 1:

```c++
#include <iostream>

using namespace std;
class Parent final
{

};

class Child: public Parent // Inheritence from the parent class is not allowed here as the parent is marked final
{

};

int main()
{
    cout << "Hello world!" << endl;
    return 0;
}
```

Eg. 2:

```c++
#include <iostream>

using namespace std;
class Parent
{
    virtual void show() final
    {

    }

};

class Child: public Parent
{
    void show() // function over-riding not allowed if the function in the base class is final
    {

    }

};

int main()
{
    cout << "Hello world!" << endl;
    return 0;
}

```

## [23.3] Lambda Expression

- Lambda expressions are used for defining unnamed functions.
- As Lambda expressions are unnamed functions they are also used as a function within another function
and hence are used as nested function
- Syntax is as follows:

```c++
[capture_list](parameter_list)->return type{body};
```

e.g: 1  program to write unnamed function to display hello on screen

```c++
main()
{
[](){cout<<"Hello";}(); // The () in the end is for calling this function

}
```

e.g: 2

```c++
[](int x, int y){cout << "Sum: " << x+y;}(10,5);
```

e.g: 3

```c++
int x = [](int x, int y){return x+y;} (10, 5); // WE ARE NOT WRITING RETURN TYPE AS C++ HAS AUTO RETURN TYPE BY DEFAULT.
cout << x << endl;
```

e.g: 4

```c++
auto f = [](){cout << "Hello";};
// function assigned to variable or reference or pointer to a function f
// now we can call the function like this :

f();

```

e.g: 5 // return type mentioned

```c++
main()
{

int s=[](int x, int y) -> int{return x+y;}(10, 5);
}
```

e.g: 6 // One can access the local variable of the function inside the named function

```c++
main()
{

int a = 10;
int b = 5;
[a, b] () {cout << a << " " << b;}(); // notice a and b in capture list

[a, b] () {cout << ++a << " " << ++b;}(); // This cannot be done as captured variables cannot be modified.

[&a, &b] () {cout << ++a << " " << ++b;}(); // By creating a reference now we can modify the values
}
```

e.g: 7 

```c++
template <typename T>
void fun (T p)
{
    cout << "Value returned from a function" << endl;
    p();
}

main()
{
    // Unnamed function can also be passed to other function as an argument

    int k=10;
    auto fk = [&k](){cout << ++k << endl;}; // 
    fun(fk);
    fun(fk);
    fun(fk);
	
	return 0;
	}

```

## [23.4] Smart Pointers

- While using the heap it is necessary to de-allocate the memory when not in use.
- Languages like java, C# provides the way for garbage collection thus de-allocating memory not in use thus preventing memory leak.

- C++ provides smart pointers to automatically de-allocate the object not in use when the object goes out of scope

* Problem with normal pointers:

```c++
fun()
{
	rectangle *p = new rectangle(); pointer deleted when the function ends but rectangle object is not deallocated
	
	
	// delete p; // usually avoided by the carelessness of the program
	}
	
main()
{

while(1)
{
fun(); // infinite loop creating memory in heap
}

}
```

- Note here that this infinite loop will create severe memory leak as each time rectangle object is not de-allocated.

* There are 3 kinds of smart pointers available in C++:

1. unique_ptr
2. shared_ptr
3. weak_ptr

These smart pointes will automatically de-allocate objects when it goes out of scope.

### 1. unique_ptr

```c++
fun()
{
	unique_ptr<rectangle> p1(new rectangle(10, 5)); //unique_ptr<type_of_ptr> ptr_name(object())

	cout << p1->area();
	cout <<p1->perimeter();
	}
```

- here ptr p1 is pointing to the object rectangle in heap but this whole pointer and object is under unique_ptr class hence after the fun ends the pointer p1 is deleted and hence object is also de-allocated automatically.

- In a nutshell the object which is within the context of unique_ptr is de-allocated automatically.
- here p1 is an object of unique_ptr.

* **unique_ptr means at a time only one pointer will be pointing upon an object but we can move the pointer p1 to p2.**

### 2. shared_ptr

- Shared pointer can have **more then one pointer pointing to the same object.**
- The shared_ptr will maintain the reference counter **ref_counter** which will keep the count of the number of pointers pointing to an object.
- **WE CAN KNOW THE VALUE OF REF_COUNTER BY CALLING THE FUNCTION use_counter() on a shared pointer**

### 3. weak_ptr

- weak_ptr is same as shared_ptr but will not maintain ref_counter.
- Hence it is said to have weak hold on objects
- The reason for weak_ptr is if the pointers are holding the objects and requesting for other objects
then they may form a deadlock between pointers. 
- **Hence weak_ptr are used for AVOIDING DEADLOCK SITUATION.**

```c++
#include <iostream>
#include <memory>


using namespace std;


class Rectangle
{
    int length;
    int breadth;

public:

    Rectangle(int l, int b)
    {

        length = l;
        breadth = b;
    }

    int area()
    {
        return length * breadth;
    }
};

int main()
{

    cout << "------------ unique_ptr ---------------" << endl;

    unique_ptr <Rectangle> ptr (new Rectangle(10, 5));
    cout << ptr->area() << endl;

    // unique_ptr <Rectangle> ptr = ptr2 ; // notice here that another pointer cannot be pointed to the object

    unique_ptr <Rectangle> ptr2;
    ptr2=move(ptr);
    cout << "ptr2 " << ptr2-> area() << endl;
    //cout << ptr->area() << endl; // notice how this doesn't prints anything as the pointer is null


    cout << "------------ shared_ptr ---------------" << endl;

    shared_ptr <Rectangle> ptr3 (new Rectangle(10, 5));
    cout << ptr3->area() << endl;

    shared_ptr <Rectangle> ptr4;


    ptr4=ptr3;
    cout << "ptr4 " << ptr4-> area() << endl;
    cout << "ptr3 " << ptr3->area() << endl;

    cout << ptr3.use_count()<< endl;
    return 0;
}

```



## [23.5] InClass Initializers and Delegation of Constructors

```c++
#include <iostream>

using namespace std;

class Test
{
    int x=10; // notice how we are assigning values here directly to the members of the class
    int y=13; // This is called as InClass Initializers. This feature was not available in previous versions of C++

public:

    Test(int a, int b)
    {
        x=a;
        y=b;
    }

    Test():Test(1,1) // This is Delegation of a constructor where one constructor can call another in the same class
    {}				 // Here a non-parameterized constructor is calling a parameterized constructor
					 // This non-parameterized is used for validating the data members of the parameterized constructor
};

int main()
{
   // cout << "Hello world!" << endl;
    return 0;
}

```

## [23.6] Ellipsis

- Ellipsis is used for taking variable number of arguments in a function
- But Ellipsis should know number of arguments passed.
- Syntax is first argument is no of elements and rest of the elements are all the elements.
- printf and scanf uses ellipses for variable number of arguments

E.g.

```c++
int sum(int n, ...)
{

// for accessing the elements va_list class is available.

va_list list;
va_start(list, n);

int s=0;

for(int i=0; i<n; i++)
s+ = va_arg(list, int) // This function will take the list and we have to also mention datatype here
					  // This will take the elements one by one from the list of ellipsis and everytime we have to mention datatype of the argument.
					  
va_end(list);		 // For ending the list of arguments
return s;
}

main()
{
cout << sum(3, 10, 20, 30)
cout << sum(5, 10, 20, 30, 40, 50)
}

```

