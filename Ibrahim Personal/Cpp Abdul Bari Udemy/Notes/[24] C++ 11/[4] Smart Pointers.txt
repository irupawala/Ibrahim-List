- While using the heap it is necessary to deallocate the memory when not in use.
- Languages like java, C# provides the way for garbage collection thus deallocating memory not 
in use thus preventing memory leak.

- C++ provides smart pointers to automatically dealocate the object not in use when the object goes
out of scope

* Problem with normal pointers:

fun()
{
	rectangle *p = new rectangle(); pointer deleted when the function ends but rectangle object is not deallocated
	
	
	// delete p; // usually avoided by the carelessness of the program
	}
	
main()
{

while(1)
{
fun(); // infinite loop creating memory in heap
}

}

- Note here that this infinite loop will create severe memory leak as each time rectangle object is not
deallocated.

* There are 3 kinds of smart pointers available in C++:

1. unique_ptr
2. shared_ptr
3. weak_ptr

These smart pointes will automatically deallocate objects when it goes out of scope.

1. unique_ptr:

fun()
{
	unique_ptr<rectangle> p1(new rectangle(10, 5)); //unique_ptr<type_of_ptr> ptr_name(object())

	cout << p1->area();
	cout <<p1->perimeter();
	}
	
- here ptr p1 is pointing to the object rectangle in heap but this whole pointer and object is under unique_ptr
class hence after the fun ends the pointer p1 is deleted and hence object is also deallocated automatically.

- In a nutshell the object which is within the context of unique_ptr is deallocated automatically.
- here p1 is an object of unique_ptr.

** unique_ptr means at a time only one pointer will be poiting upon an object 
but we can move the pointer p1 to p2.

2. shared_ptr:

- Shared pointer can have more then one pointer pointing to the same object.
- the shared_ptr will maintain the reference counter ref_counter which will keep the count of the 
number of pointers pointing to an object.

** WE CAN KNOW THE BALUE OF REF_COUNTER BY CALLING THE FUNCTION use_counter() on a shared pointer

3. weak_ptr:

- weak_ptr is same as shared_ptr but will not maintain ref_counter.
- Hence it is said to have weak hold on objects
- The reason for weak_ptr is if the pointers are holding the objects and requesting for other objects
then they may form a deadlock between pointers. 
- Hence weak_ptr are used for AVOIDING DEADLOCK SITUATION.

