- Iterators are available in every collection.
- Using vectors we don't have to worry whether the array is full or not, how to add or delete.

E.g. 1:

- Eg of using an object vector and inserting elements:

# include <vector>

int main()
{

	vector <int> v() // if you mention the size in brackets it will create a vector of that size or 
					 // else it will create an array of size 16
					 
	vector <int> v = {10, 20, 40, 90}; // you can also mention the initial vector
	
	v.push_back(25);
	v.push_back(70);
	v.pop_back();
	
}

Iterators are used for accessing each elements in the vector

1. For each loop (introduced in C++11)

	for (int x: v)
	cout << x;
	
2. Use of Iterators classes

- Now we can get object of iterator and iterate through the list of elements as shown below:

vector<int>::iterator itr=v.begin();

// here iterator class belongs to a vector class. 
// The object of iterator is itr.
// itr = v.begin(); This will initialize the iterator to the starting point of the vector.
// begin and end functions are available in all containers. begin gives the starting of the collection and end 
gives end of the collection.
// We also have rbegin and rend functions which helps in traversing a 
collection from rear end. reverse traversing

vector<int>::iterator itr;
for (itr=v.begin(); itr!=v.end(); itr++)
	cout << *itr; // * because itr is like a pointer to the elements inside the collection
	
	

E.g. 2: // see how by one simple change we have changed vector to list. 

# include <list>

int main()
{
			 
	list <int> v = {10, 20, 40, 90}; 
	
	v.push_back(25);
	v.push_back(70);
	v.pop_back();
	
	
	
	list<int>::iterator itr;
	for (itr=v.begin(); itr!=v.end(); itr++)
	cout << *itr; 
		
}	

- Notice that similarly we can also change the container to forward_list, dqueue as the functions are same
but not set as for set we cannot use push_back and push_front as it has the functions like insert 

- Handling of the data structures is the same but the performance and internal memory organization 
will be different.

	
